ads_version: '2.0'
type: rule_set
agent: all
tier: 2
priority: high
async_patterns_rules:
  fastapi_routes:
    blocking_operations:
      description: CPU-bound tasks (inference, heavy image proc) in async def block
        the event loop
      rule: Use 'def' (threadpool) OR 'await loop.run_in_executor' for blocking calls
      patterns:
        prohibited:
          description: Blocking call in async def
          example: "@app.post(\"/predict\")\nasync def predict(image):\n    # BLOCKS\
            \ the event loop! No other requests processed.\n    return model.forward(image)\n"
        recommended:
          description: Starlette ThreadPool (Simplest)
          example: "@app.post(\"/predict\")\ndef predict(image):\n    # FastAPI runs\
            \ this in a threadpool automatically\n    return model.forward(image)\n"
        advanced:
          description: Explicit Executor (Best for mixed workloads)
          example: "@app.post(\"/predict\")\nasync def predict(image):\n    # Non-blocking\
            \ preload\n    await check_cache()\n    # Run blocking inference in specific\
            \ executor\n    loop = asyncio.get_running_loop()\n    return await loop.run_in_executor(model_executor,\
            \ model.forward, image)\n"
  io_operations:
    network_calls: MUST use async clients (httpx, aiohttp) instead of sync (requests)
    file_io: Prefer aiofiles for large files, or run_in_executor for pathlib ops
    database: Use async drivers (asyncpg, motor) where possible
id: FW-006
validates_with: AgentQMS/standards/schemas/compliance-checker.py
compliance_status: unknown
memory_footprint: 100
keywords:
- async
- patterns
- rules
fuzzy_threshold: 0.8
