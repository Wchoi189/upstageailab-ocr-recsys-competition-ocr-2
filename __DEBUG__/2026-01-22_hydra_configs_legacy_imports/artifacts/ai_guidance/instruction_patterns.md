# AI Agent Instruction Patterns for Refactoring

**Source**: Conversation analysis
**Date**: 2026-01-22
**Context**: Effective strategies for instructing AI agents during large-scale refactoring
**Python Manager**: uv

---

## Overview

For deep refactors (50+ broken imports), **conversational style fails**. AI agents get lost in "noise." This document provides systematic instruction patterns that enable AI agents to execute complex refactoring tasks without hallucination.

---

## Core Principle: Multi-Phased Execution + Machine-Parseable Context

**Instead of**: *"Here is a log, fix the imports"*
**Use**: **"Context-Targeted Repair Operations"**

---

## Request Template Pattern

### Structure

```markdown
> **Goal:** [Specific, measurable objective]
> **Constraint:** [Hard limits - what NOT to do]
> **Reference Roadmap:** [Link to friction report or architecture doc]
> **Input Data:** [Structured data - JSON/YAML from analysis tools]
```

### Example

```markdown
> **Goal:** Align `ocr.domains.detection` imports with the new `ocr.core` structure.
> **Constraint:** Do not guess. Only use the provided `MAPPING_LIST`.
> **Reference Roadmap:** See #1 Friction Report in `debugging_pain_points.md`
> **Input Data:** [Insert JSON output of ADT `analyze-dependencies` tool]
```

---

## Instruction Style Selection

Choose the appropriate style based on task type:

| Task Type         | Style                     | Example                             |
| ----------------- | ------------------------- | ----------------------------------- |
| **Discovery**     | Pure Log Output           | "Run audit and report findings"     |
| **Execution**     | Direct Execution Oriented | "Apply these 5 diffs"               |
| **Validation**    | Verification Loop         | "Run audit ‚Üí fix ‚Üí verify ‚Üí repeat" |
| **Complex Logic** | Guardrail-Based           | "If X then Y, else fail"            |

### Guardrail-Based Example

```markdown
**Guardrail 1**: If an import starts with `ocr.detection`, it MUST be changed to `ocr.domains.detection`. Any deviation is a failure.

**Guardrail 2**: If `intelligent-search` returns `NOT_FOUND`, flag for human review. Do NOT guess the path.

**Guardrail 3**: After every 5 fixes, run `uv pip install -e .` to refresh the symbol table.
```

---

## Machine-Parseable Target Lists

**Problem**: AI struggles with "where am I in the file?"
**Solution**: Send a **Target List** generated by analysis tools

### Format

```yaml
# TASK_BATCH_01: Broken Import Alignment
target_files:
  - file: "ocr/domains/detection/evaluation.py"
    line: 16
    current: "from ocr.core.metrics import CLEvalMetric"
    action: "MOVE_TO"
    new_target: "ocr.core.evaluation.metrics.CLEvalMetric"

  - file: "ocr/pipelines/orchestrator.py"
    line: 101
    current: "from ocr.domains.detection.module import DetectionPLModule"
    action: "FIX_PATH"
    new_target: "ocr.domains.detection.module.DetectionPLModule"
```

**Why This Works**: Removes "Irrelevant Noise." The AI doesn't have to think; it just performs the mapping.

---

## The Verification Loop Pattern

For systematic migration, use this loop structure:

```markdown
### Phase 1: Environment Lock (Guardrail)
* Execute `uv run python scripts/migration_guard.py`
* **Hard Stop**: If "Ghost Code" or "Site-Packages" is detected, stop and report.

### Phase 2: Target Resolution
* For each entry in `broken_targets.json`:
  1. If target is dynamic (`${...}`), use `yq` to find the variable source
  2. Use `adt intelligent-search` to find the current physical location
  3. Propose a `yq` command to update the YAML

### Phase 3: Verification
* Re-run `master_audit.py`. The "Kill List" must be 0.
```

---

## Context Injection Strategies

### 1. Environment Context

```markdown
**Context Injection**: "The environment is in 'Editable' mode. Do not ignore `ModuleNotFoundError`‚Äîthey are real."
```

### 2. Roadmap Context

```markdown
**The Roadmap**: Provide the `context-tree` output so the agent knows the *new* structure.
```

### 3. Execution Loop Context

```markdown
**The Loop**:
* **Audit**: Run `scripts/audit/master_audit.py`
* **Search**: Use `adt intelligent-search` on the first 5 broken items
* **Edit**: Use `adt apply-diff` to fix them
* **Verify**: Run the audit again to confirm the "Kill List" count decreased
```

---

## Structured Execution Protocol

For Hydra alignment tasks:

```markdown
### üõ†Ô∏è PHASE 1: IMPORT ALIGNMENT EXECUTION

**Guardrails:**
1. ONLY modify the lines identified in the manifest
2. Use 'adt intelligent-search' to find the NEW location of each 'faulty_module'
3. If 'intelligent-search' returns 'NOT_FOUND', flag for human review
4. Ensure 'uv pip install -e .' is run after every 5 fixes to refresh the symbol table

**Execution Manifest:**
```json
[
  {
    "action": "ALIGN_IMPORT",
    "file": "ocr/domains/detection/evaluation.py",
    "faulty_module": "ocr.core.metrics",
    "symbols": ["CLEvalMetric"],
    "status": "PENDING"
  }
]
```
```

---

## Tool-Specific Instruction Patterns

### For Python Import Fixes

```markdown
**Tool**: `adt intelligent-search` + `apply-diff`
**Instruction Style**: Direct Execution

"Fix imports using the provided mapping. For each broken import:
1. Run `adt intelligent-search <symbol>`
2. Update import statement with result
3. Verify with `uv run python -c 'import <module>'`"
```

### For Hydra Target Fixes

```markdown
**Tool**: `yq` (Selective Update)
**Instruction Style**: Guardrailed Execution

"Only update targets matching pattern X. Use:
```bash
yq -i '.. | select(. == "OLD_PATH") = "NEW_PATH"' config.yaml
```

Verify with:
```bash
yq eval '.. | select(has("_target_"))' config.yaml
```"
```

### For Mass Refactoring

```markdown
**Tool**: `sg_search` (AST-Grep)
**Instruction Style**: Pattern-Oriented

"Apply this structural rewrite to all model factories:
```bash
sg_search --pattern 'get_model_by_cfg($$$)' --rewrite 'get_model_by_cfg($$$, _recursive_=False)'
```"
```

---

## Batch Processing Strategy

For large-scale fixes (50+ items):

```markdown
**Batch Size**: Process 10 items at a time
**Verification**: After each batch, run validation
**Rollback**: If batch fails, revert and flag for manual review

```json
{
  "batch_1": [...],  // Items 1-10
  "batch_2": [...],  // Items 11-20
  "batch_3": [...]   // Items 21-30
}
```
```

---

## Error Handling Patterns

### Fail-Fast Pattern

```markdown
**On Error**: Stop immediately and report
**Do NOT**: Attempt to guess or work around
**Do**: Provide exact error message and context
```

### Graceful Degradation Pattern

```markdown
**On Error**: Log the failure
**Continue**: With remaining items
**Report**: Summary of successes and failures at end
```

---

## Presentation Best Practices

1. **Use Structured Data**: JSON/YAML over prose
2. **Provide Examples**: Show exact commands to run
3. **Set Clear Boundaries**: What to do, what NOT to do
4. **Include Verification**: How to check if it worked
5. **Batch Appropriately**: Don't overwhelm with 100+ items at once

---

## Anti-Patterns to Avoid

‚ùå **Vague Instructions**: "Fix the imports"
‚úÖ **Specific Instructions**: "Update imports in files listed in manifest.json using adt intelligent-search"

‚ùå **No Verification**: "Make the changes"
‚úÖ **With Verification**: "Make changes, then run audit to confirm count decreased"

‚ùå **Unbounded Scope**: "Fix everything"
‚úÖ **Bounded Scope**: "Fix the 10 items in batch_1.json"

‚ùå **Conversational**: "Can you help me fix these imports?"
‚úÖ **Directive**: "Execute: Fix imports using mapping in imports.json"

---

## Complete Example: Hydra Target Alignment

```markdown
## Task: Synchronize 18 Hydra Targets

**Goal**: Synchronize 18 Hydra targets with the refactored directory structure.

**Instruction**: Do not use Python to fix YAMLs. Use the provided `yq` commands.

**Verification**: After each command, run:
```bash
yq eval '.. | select(has("_target_"))' <file>
```
to verify the change was applied.

**Constraint**: If a path starts with `ocr.detection`, it is LEGACY. It must be updated to `ocr.domains.detection`.

**Execution Manifest**:
```json
{
  "targets": [
    {
      "file": "configs/data/datasets/craft.yaml",
      "old_target": "${data.dataset_path}.ValidatedOCRDataset",
      "new_target": "ocr.data.datasets.base.ValidatedOCRDataset",
      "command": "yq -i '.. | select(. == \"${data.dataset_path}.ValidatedOCRDataset\") = \"ocr.data.datasets.base.ValidatedOCRDataset\"' configs/data/datasets/craft.yaml"
    }
  ]
}
```

**Verification Loop**:
1. Execute command
2. Run verification
3. If successful, proceed to next
4. If failed, stop and report
```

---

## See Also

- `migration_guard_implementation.md` - Validation before execution
- `yq_mastery_guide.md` - Advanced yq techniques
- `adt_usage_patterns.md` - Agent Debug Toolkit usage
