# Agent Debug Toolkit (ADT) Usage Guide for AI Agents
# Version: 1.2 (Phase 3 - AST-Grep)

tools:
  resolve_hydra_configs:
    desc: Map Hydra config _target_ keys to Python files.
    args:
      config_dir: Path to config root (e.g., "configs")
      module_root: Path to module root (e.g., ".")
    example: |
      adt resolve-configs configs --module-root .

  analyze_config_access:
    desc: Find code using cfg.X or config['X'].
    args:
      path: File or directory path
    example: |
      adt analyze-config src/model.py

  trace_merge_order:
    desc: Debug OmegaConf.merge() precedence.
    args:
      file: Path to python file
    example: |
      adt trace-merges src/train.py

  find_hydra_usage:
    desc: Find @hydra.main, instantiate(), etc.
    args:
      path: File or directory path
    example: |
      adt find-hydra src/

  find_component_instantiations:
    desc: Track factory patterns like get_X_by_cfg().
    args:
      path: File or directory
      component: Optional filter (e.g., "encoder")
    example: |
      adt find-instantiations src/ --component encoder

  analyze_dependencies:
    desc: Build dependency graph (imports/calls).
    args:
       path: File or directory
    example: |
       adt analyze-dependencies src/

  analyze_complexity:
    desc: Check cyclomatic complexity/nesting.
    args:
       path: File/dir
       threshold: Int (default 10)
    example: |
       adt analyze-complexity src/ -t 15

  context_tree:
    desc: Generate annotated directory tree with docstrings and semantic labels.
    args:
       path: Directory to analyze
       depth: Max depth to traverse (default 3)
       output: Format - markdown (default), json, tree
    example: |
       adt context-tree ocr/recognition --depth 2
       adt context-tree agent-debug-toolkit/src --output json
    features:
       - Extracts module docstrings and __all__ exports
       - Detects special directories (tests, configs, models, data)
       - Lists key classes and functions with their docstrings
       - Provides rich context for AI agent navigation

  intelligent_search:
    desc: Search for symbols by name or qualified path with fuzzy matching.
    args:
      query: Symbol name or qualified path (e.g., "TimmBackbone" or "ocr.models.encoder.TimmBackbone")
      root: "Root directory to search (default: current directory)"
      fuzzy: "Enable fuzzy matching for typos (default: true)"
      threshold: "Minimum similarity 0.0-1.0 (default: 0.6)"
    example: |
       # Find by class name
       adt intelligent-search "ContextTreeAnalyzer" --root src/

       # Resolve qualified path
       adt intelligent-search "agent_debug_toolkit.analyzers.context_tree.ContextTreeAnalyzer"

       # Fuzzy search (handles typos)
       adt intelligent-search "ContextTreeAnalyer" --threshold 0.7
    features:
       - Resolves Hydra _target_ paths to file locations
       - Reverse lookup: find all import paths for a class
       - Fuzzy matching for typo correction (using difflib)
       - JSON or markdown output

concepts:
  symbol_table: "Internal service mapping definitions across files."
  resolution_status:
    RESOLVED: "Static match found."
    UNRESOLVED_DYNAMIC: "Interpolation detected (${...})."
    UNRESOLVED_RELATIVE: "Relative path not fully resolved."
    NOT_FOUND: "Symbol not in scanned codebase."

# --- Edit Tools (Phase 4) ---
edit_tools:
  apply_unified_diff:
    desc: Apply git-style unified diffs with fuzzy matching for robust edits.
    args:
      diff: "Unified diff text (git diff format)"
      strategy: "exact | whitespace_insensitive | fuzzy (default: fuzzy)"
      dry_run: "Preview changes without modifying (default: false)"
    example: |
      # Apply a diff with fuzzy matching
      adt apply-diff --strategy fuzzy << 'EOF'
      --- a/src/model.py
      +++ b/src/model.py
      @@ -10,2 +10,2 @@
      -    old_function()
      +    new_function()
      EOF
    workflow: "read_file_slice → propose diff → apply_unified_diff"

  smart_edit:
    desc: Search/replace with exact, regex, or fuzzy matching.
    args:
      file: Path to file
      search: Text or pattern to find
      replace: Replacement text
      mode: "exact | regex | fuzzy (default: exact)"
      all_occurrences: "Replace all matches (default: false)"
      dry_run: "Preview without modifying (default: false)"
    example: |
      # Exact replacement
      adt smart-edit src/utils.py --search "old_name" --replace "new_name"

      # Regex replacement
      adt smart-edit src/utils.py --mode regex \
        --search 'logger\.warn\("([^"]+)"\)' \
        --replace 'logger.warning("\1")'

  read_file_slice:
    desc: Read specific line range for targeted editing of large files.
    args:
      file: Path to file
      start_line: Starting line (1-indexed)
      end_line: Ending line (inclusive)
      context_lines: "Additional context before/after (default: 0)"
    example: |
      # Read lines 50-100 with 5 lines of context
      adt read-slice src/large_file.py --start 50 --end 100 --context 5
    purpose: "Minimize context when editing large files"

  format_code:
    desc: Format code after edits to normalize style.
    args:
      path: File or directory
      style: "black | ruff | isort (default: black)"
      check_only: "Only check, don't modify (default: false)"
    example: |
      adt format src/module.py --style black

  yq_batch_edit:
    desc: "Batch update YAML files using yq (wrapper for jq). FASTEST way to refactor Hydra configs."
    args:
      command: "The yq expression to apply"
      files: "Files to update (use find | xargs for batch)"
    example: |
      # 1. Update a value in a single file
      yq -i '.optimizer.lr = 0.001' configs/train.yaml

      # 2. Batch update ALL matching targets (CRITICAL for refactoring)
      # "Find all configs where _target_ is OldClass and change it to NewClass"
      find configs/ -name "*.yaml" | xargs -I {} yq -i \
        '(.[] | select(has("_target_")) | select(._target_ == "old.path.Class") | ._target_) = "new.path.Class"' {}

      # 3. Add a new key to all model configs
      find configs/model -name "*.yaml" | xargs -I {} yq -i '.new_key = "value"' {}

      # 4. Delete a key
      yq -i 'del(.deprecated_key)' configs/config.yaml
    best_practice: "ALWAYS use single quotes for the expression to avoid shell expansion."

best_practices:
  editing_large_files:
    - "Use read_file_slice to view target region first"
    - "Propose changes as unified diff"
    - "Apply with apply_unified_diff using fuzzy strategy"
    - "Run format_code after edits"
  avoiding_failed_edits:
    - "Never rewrite entire files"
    - "Use line ranges, not whole file content"
    - "Prefer fuzzy strategy for drift tolerance"

# --- AST-Grep Tools (Phase 3) ---
ast_grep_tools:
  sg_search:
    desc: Structural code search using AST patterns. More precise than text search.
    args:
      pattern: "AST pattern (e.g., 'def $NAME($$$)' matches any function)"
      path: File or directory to search
      lang: "Language (auto-detected if not specified)"
      max_results: "Limit number of matches"
    example: |
      # Find all function definitions
      sg_search pattern="def $NAME($$$)" path="src/"

      # Find print statements
      sg_search pattern="print($MSG)" path="src/" lang="python"

      # Find classes with specific base
      sg_search pattern="class $NAME(BaseModel):" path="src/"
    pattern_syntax:
      $NAME: "Match single AST node and capture as meta-variable"
      $$$: "Match zero or more nodes (like regex ...)"
      $$ARGS: "Match multiple nodes and capture"

  sg_lint:
    desc: Run custom lint rules defined in YAML format.
    args:
      path: File or directory to lint
      rule: "YAML rule string"
      rule_file: "Path to YAML rule file"
    example: |
      # Find print statements as lint violations
      sg_lint path="src/" rule="
        id: no-print
        language: Python
        rule:
          pattern: print($$$)
        message: 'Avoid print statements'
      "
